# Python DAY01

张志刚的git：git clone https://github.com/MrZhangzhg/nsd2019.git

## 一、Python概述

### (一)Python简介

#### 1、Python起源

Guido van Rossum于1989年底始创了python

1991年初,python发布了第一个公开发行版

为了更好的完成荷兰的CWI(国家数学和计算机科学研究院)的一个研究项目而创建



#### 2、Python版本

(1)Python2.X

目前所有系统默认安装的版本

(2)Python3.X

2009年2月13日发布

在语法和功能上有较大调整

Python的发展趋势



#### 3、Python的特点

##### (1)高级

有高级的数据结果,缩短开发时间与代码里

##### (2)面向对象

为数据和逻辑相分离的结构化和过程化编程添加了新的活力

##### (3)可升级

提供了基本的开发模块,可以在它上面开发软件,实现代码的重用

##### (4)可扩展

通过将其分离为多个文件或模块加以组织管理

(5)可移植性

Python是用C语言写的,又由于C语言的可移植性,使得python可以运行在任何带有ANSI C编译器的平台上

(6)易学

Python关键字少、结构简单、语法清晰

(7)易读

没有其他语言通常用来访问变量、定义代码块和进行模式匹配的命令式符号

(8)内存管理器

内存管理是由Python解释器负责的



## 二、Python环境准备

### (一)安装Python环境

#### 1、安装依赖包

```shell
]#	yum install -y	gcc gcc-c++	zlib-devel openssl-devel readline-devel  libffi-devel sqlite-devel tcl-devel tk-devel
```

#### 2、安装Python3

```shell
#	tar xzf Python-3.6.7.tar.gz
#	cd	Python-3.6.7
#	./configure	--prefix=/usr/local
#	make &&	make install
```

### (二)虚拟环境

1、一个虚拟环境就是一个隔离的工作目录

2、安装Python模块,就是安装到Python的虚拟环境

3、删除虚拟环境目录,即可将Python环境清理干净

#### 创建Python3环境目录

```shell
[student@room9pc01 ~]$ python3 -m venv ~/nsd1908
[student@room9pc01 下载]$ source ~/nsd1908/bin/activate      #激活虚拟环境
(nsd1908) [student@room9pc01 ~]$ python -V                  #检查版本
Python 3.6.7
(nsd1908) [student@room9pc01 ~]$ which python               #查看Python解释器
~/nsd1908/bin/python
```

## 三、Python起步

### (一)Python运行方式

#### 1、交互解释器

• 进入交互解释器

```
[root@zzghost1	bin]#	python3
Python 3.6.3	(default,	Oct 13	2017,	11:38:12)
[GCC	4.8.5	20150623	(Red	Hat 4.8.5-4)]	on	linux
Type "help",	"copyright",	"credits"	or "license"	for	more information
```

• 退出交互解释器

```
>>>	exit()
或
>>>	ctrl	+	d
```



#### 2、文件形式

• 明确指定解释器

[root@zzghost1	day01]#	python3	hello.py

• 赋予python文件可执行权限
[root@zzghost1	day01]#	chmod +x	hello.py
[root@zzghost1	day01]#	./hello.py

### (二)Python语法结构

#### 1、语句块缩进

python代码块通过缩进对齐表达代码逻辑而不是使用大括号
• 缩进表达一个语句属于哪个代码块
• 缩进风格
– 1或2:可能不够,很难确定代码语句属于哪个块
– 8至10:可能太多,如果代码内嵌的层次太多,就会使得代码很难阅读
– 4个空格:非常流行, 范·罗萨姆支持的风格

• 缩进相同的一组语句构成一个代码块,称之代码组
• 首行以关键字开始,以冒号 : 结束,该行之后的一行或多行代码构成代码组
• 如果代码组只有一行,可以将其直接写在冒号后面,但是这样的写法可读性差,不推荐

#### 2、注释及续行

• 首要说明的是:尽管Python是可读性最好的语言之一,这并不意味着程序员在代码中就可以不写注释
• 和很多UNIX脚本类似,python注释语句从#字符开始    (ctrl+/):注释快捷方式
• 注释可以在一行的任何地方开始,解释器会忽略掉该行#之后的所有内容
• 一行过长的语句可以使用反斜杠\分解成几行

#### 3、同行多个语句

• 分号 ; 允许你将多个语句写在同一行上
• 但是些语句不能在这行开始一个新的代码块
• 因为可读会变差,所以不推荐使用

#### 4、输出语句

• 获取帮助

```
>>> help(print)
```

• 使用方式

```shell
>>>	print('Hello World!')
>>>	print('Hello'	+	'World!')
>>>	print('Hello',	'World!')
>>>	print('Hello',	'World!',	sep='***')
>>>	print('Hello',	'World!',	sep='***',	end='')
```

#### 5、输入语句

• 获得帮助

```
>>>	help(input)
```

使用方式(注意,返回值一定是字符类型)

```shell
>>>	num =	input("Number:	")
Number:	20
>>>	num +	10
Traceback (most	recent	call	last):
File	"<stdin>",	line	1,	in	<module>
TypeError:	must	be str,	not int
```

Python里面变量赋值是自右向左做运算

int可将字符串形式的数字转换成整数数字

str可将任意类型的数据转换成字符串

```shell
n = input('number:')
print(n)
print(int(n)+5)
print(n + str(5))
```

返回值:

```shell
number:5
5
10
55
```

举例:

```shell
u = input('请输入用户名:')
print('欢迎用户:' + u)
print('欢迎用户:', u)
print('欢迎用户:%s' % u)
# '' % () => 字符串中包换变化数据,采用的方法
# 如果引号中只有一个变化数据,不用() => '%s' % 10
# 如果引号中右多个变化数据,必须 用() => '%s is %s year old' % ('zs' , 20)
```

返回值:

```shell
请输入用户名:huihui
欢迎用户:huihui
欢迎用户: huihui
欢迎用户:huihui
```



## 四、Python变量

### (一)变量的定义

### 1、 变量名称约定

硬性要求,必须符合以下条件

– 第一个字符只能是大小写字母或下划线
– 后续字符只能是大小写字母或数字或下划线
– 区分大小写

### 2、 python是动态类型语言

即不需要预先声明变量的类型



### 3、 推荐采用的全名方法

不是硬性要求

– 变量名全部采用小写字母                       pythonstring
– 简短、有意义                                     pystr
– 多个单词间用下划线分隔                    py_str
– 变量名用名词,函数名用谓词(动词+名词)     phone / update_phone
– 类名采用驼峰形式

### (二)变量的赋值

Python里面变量赋值是自右向左做运算

将=号右边的表达式计算结果,赋值给左边的变量

• 变量的类型和值在赋值那一刻被初始化
• 变量赋值通过等号来执行

```shell
>>> a = 10 
>>> b = 10 + 5
>>> a = c + 5   # c未定义,报错,变量使用前必须赋值
Traceback (most recent call last):
  File "<stdin>", line 1, in <modu
le>
NameError: name 'c' is not defined
>>> a = a +5
>>> a
15
>>> a +=5   #上面写法的简写
>>> a
20

```

• python也支持增量赋值

```shell
>>>		n	+=	1								#等价于n	=	n	+	1
>>>		n	*=	1								#等价于n	=	n	*	1
>>>	i++
File	"<stdin>",	line	1
i++
^
SyntaxError:	invalid	syntax
```



### (三)运算符

#### 1、 标准算术运算符

```python
+ - * / // % **

>>> 5 / 3 
1.6666666666666667
>>> 5 // 3   # 只保留商
1
>>> 5 % 3    # 求余、模运算
2
>>> divmod(5, 3)  # 同时得到商和余数
(1, 2)
>>> a, b = divmod(5, 3)  # 将商和余数分别赋值
>>> a
1
>>> b
2
>>> 2 ** 3 # 乘方、幂运算
8
>>> 4 ** 5
1024
```

#### 2、 比较运算符

返回True或False

```python
< <= > >= == !=

>>> 10 < 20 < 30  #python支持连续比较
True
>>> 10 < 20 > 15  # 10 < 20 and 20 > 15 可读性不好,不建议使用
True

```

#### 3、逻辑运算符

```python
and not or

>>> 10 > 5 and 5 > 3  #and两侧全为True,最终结果才为True,否则为False
True
>>> 10 > 5 and 5 < 3
False

>>> 10 > 5 or 5 > 8  # or两侧全为False,最终结果才为False,否则为True
True
>>> 10 > 50 or 5 > 8
False

>>> 5 > 3
True
>>> not 5 > 3   # not取反,将True变False,将False变True
False
>>> not 5 > 30
True

```



## 五、数据类型概述

### (一)数字

#### 1、基本数字类型

• int:有符号整数
• bool:布尔值
– True:1
– False:0
• float:浮点数
• complex:复数

```python
>>> True + 5  # True的值为1
6
>>> False * 5  # False的值为0
0

```



#### 2、数字表示方式

• python默认以十进制数显示
• 数字以0o或0O开头表示为8进制数
• 数字以0x或0X开头表示16进制数
• 数字以0b或0B开头表示2进制数

```Python
>>> 0o11   # 以0o或0O开头的是8进制数
9
>>> 0x11   # 以0x或0X开头的是16进制数
17
>>> 0b11   # 以0b或0B开头的是2进制数
3

>>> hex(100)  转成16进制
'0x64' 
>>> oct(100)  转成8进制
'0o144'
>>> bin(100)  转成2进制
'0b1100100'

```



### (二)序列对象

#### 1、定义字符串

• python中字符串被定义为引号之间的字符集合
• python支持使用成对的单引号或双引号
• 无论单引号,还是双引号,表示的意义相同
• python还支持三引号(三个连续的单引号或者双引号),可以用来包含特殊字符
• python不区分字符和字符串

三引号举例:

```python
>>> words = '''hello
... welcome
... hao'''
>>> print(words)
hello
welcome
hao
>>> words
'hello\nwelcome\nhao'

```

#### 2、字符串切片

• 使用索引运算符[ ]和切片运算符[ : ]可得到子字符串
• 第一个字符的索引是0,最后一个字符的索引是-1
• 子字符串包含切片中的起始下标,但不包含结束下标

```python
>>>	py_str =	'python'
>>> 'python'[0]
'p'
>>>	py_str[0]
'P'
>>>	py_str[-2]
'o'
>>>	py_str[2:4] # 取切片时,起始下标包含,结束下标不包含
'th'
>>>	py_str[2:]  # 结束下标不写,表示取到结尾
'thon'
>>>	py_str[:4]  # 起始下标不写,表示从头开始取
'Pyth'
>>> s1[2:6]   # 切片时,下标越界不犯错
'thon'
>>> s1[:]     # 从开头取到结尾
'python'
>>> s1[::2]   # 第二个冒号后面的数字,是步长
'pto'
>>> s1[1::2]
'yhn'
>>> s1[::-1]   # 步长为负,表示自右向左取
'nohtyp'
>>> s1[::-2]
'nhy'

>>> 't' in s1   #成员关系判断,t在字符串中吗?
True
>>> 'th' in s1
True
>>> 'to' in s1   # t和o在字符串中不联系,返回False
False
>>> 'to' not in s1 # to不在字符串中吗?
True

```



#### 3、字符串连接操作

• 使用+号可以将多个字符串拼接在一起
• 使用*号可以将一个字符串重复多次

```python
>>>	py_str =	'python'
>>>	is_cool =	'is	Cool‘
>>>	print	py_str +	'	'	+	is_cool
python	is	Cool
>>>	py_str *	2
'pythonpython'
```



#### 4、定义列表

• 可以将列表当成普通的“数组”,它能保存任意数量任意类型的python对象
• 像字符串一样,列表也支持下标和切片操作
• 列表中的项目可以改变

类似于shell中数组

~~~python
>>>	alist =	[1,	"tom",	2,	"alice"]
>>>	alist[1]	=	'bob‘
>>>	alist[2:]
[2, 'alice']

>>> alist = [10, 20, 'tom', 'jerry', [1, 2]]
>>> len(alist)
5
>>> alist[0]
10
>>> alist[2:4]
['tom', 'jerry']

~~~



#### 5、列表操作

• 使用in或not in判断成员关系
• 使用append方法向列表中追加元素

```python
>>> alist[-1] = 100
>>> alist
[10, 20, 'tom', 'jerry', 100]
>>> 10 in alist
True
>>> 'o' in alist
False
>>> alist + [200]    # 同样类型数据才能相加运算  ,这叫做列表拼接 ,返回新列表,原始列表不变
[10, 20, 'tom', 'jerry', 100, 200]
>>> alist + 200    
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only concatenate list (not "int") to list
>>> alist * 3       # 列表重复3次,返回新列表,原始列表不变
[10, 20, 'tom', 'jerry', 100, 10, 20, 'tom', 'jerry', 100, 10, 20, 'tom', 'jerry', 100]

>>> alist = [1, 2, 3]
>>> blist = alist
>>> blist
[1, 2, 3]
>>> blist.append(10)
>>> blist
[1, 2, 3, 10]
>>> alist
[1, 2, 3, 10]
```



#### 6、元组的定义及操作

• 可以认为元组是“静态”的列表
• 元组一旦定义,不能改变

```python
>>>	atuple =	(1,	"tom",	2,	"alice")
>>>	'tom'	in	atuple
True
>>>	atuple[0]	=	3   #元组不可变,不能改值
Traceback (most	recent	call	last):
File	"<stdin>",	line	1,	in	<module>
TypeError:	'tuple'	object	does	not	support	item	assignment
```



### (三)字典

#### 1、字典的定义及操作

• 字典是由键-值(key-value)对构成的映射数据类型
• 通过键取值,不支持下标操作

```python
>>>	user_dict =	{'name':'bob',	'age':23}
>>>	use_dict['gender']	=	'male'
>>>	'bob'	in	user_dict  # bob是字典的key吗?
False
>>>	'name'	in	user_dict
True
>>>	user_dict[0]
Traceback (most	recent	call	last):
File	"<stdin>",	line	1,	in	<module>
KeyError:	0
>>> user_dict['name']  
'bob'
```



#### 2、数据类型比较

(1)按存储模型分类
– 标量类型:数值、字符串
– 容器类型:列表、元组、字典
(2)按更新模型分类:
– 可变类型:列表、字典
– 不可变类型:数字、字符串、元组
(3)按访问模型分类
– 直接访问:数字
– 顺序访问:字符串、列表、元组
– 映射访问:字典



# Python DAY02

## 一、判断语句

### (一)if语句

#### 1、if语句语法结构

标准if条件语句的语法

```python
if	expression:
if_suite
else:
else_suite
```

• 如果表达式的值非0或者为布尔值True, 则代码组if_suite被执行;否则就去执行else_suite
• 代码组是一个python术语,它由一条或多条语句组成,表示一个子代码块

#### 2、if语句示例解析

• 只要表达式数字为非零值即为True

```python
>>>	if	10:
...	print('Yes')
Yes
```

• 空字符串、空列表、空元组、空字典的值均为False

```python
>>>	if			"":
...		print('Yes')
...	else:
...		print('No')
No
```

#### 3、条件表达式

• Python 在很长的一段时间里没有条件表达式(C ? X :Y),或称三元运算符,因为范·罗萨姆一直拒绝加入这样的功能
• 从Python 2.5集成的语法确定为: X if C else Y

```python
>>>	x,	y	=	3,	4
>>>	smaller	=	x	if	x	<	y	else	y
>>>	print	smaller
3
```

#### 4、案例1:判断合法用户

1. 创建login2.py文件

2. 提示用户输入用户名和密码

3. 获得到相关信息后,将其保存在变量中

4. 如果用户输的用户名为bob,密码为123456,则输出Login successful,否则输出Login incorrect

  ```python
  import getpass
  username = input('请输入用户名: ')
  passwd = getpass.getpass('请输入密码: ')
  if username == 'bob' and  passwd == '123456' :
      print('login successful')
  else:
      print('login incorrect')
  ```

  

### (二)扩展if语句

#### 1、扩展if语句结构

```python
if expression1:
if_suite
elif expression2:
elif_suite
else:
else_suite
```

#### 2、案例2

• 创建grade.py脚本,根据用户输入的成绩分档,要求
如下:

1. 如果成绩大于60分,输出“及格”

2. 如果成绩大于70分,输出“良”

3. 如果成绩大于80分,输出“好”

4. 如果成绩大于90分,输出“优秀”

5. 否则输出“你要努力了”

   ```python
   point = int(input('请输入成绩: ' ))
   if point >= 90 :
       print('优秀')
   elif point >= 80 :
       print('好')
   elif point >= 70 :
       print('良')
   elif point >= 60 :
       print('及格')
   else:
       print('你要努力了')
   ```

   ```python
   point = int(input('请输入成绩: ' ))
   if 70 > point >= 60:
       print('及格')
   elif 80 > point >=70:
       print('良')
   elif 90 > point >=80:
       print('好')
   elif point >= 90:
       print('优秀')
   else:
       print('你要努力了!!!')
   ```

   

3、案例3

• 编写game.py,要求如下:
1. 计算机随机出拳
2. 玩家自己决定如何出拳
3. 代码尽量简化

```python
import random
choices = ['剪刀', '石头', '布']
computer = random.choice(choices)
player = input('请出拳(剪刀/石头/布): ')
print('Your choice:%s , computer choice:%s' % (player, computer))
if player == '剪刀':
    if computer == '剪刀':
        print('\033[32;1mdraw\033[0m')
    elif computer == '石头':
        print('\033[31;1mYou lose!!!\033[0m')
    else:
        print('\033[31;1mYou Win!!!\033[0m')
elif player == '石头':
    if computer == '剪刀':
        print('\033[31;1mYou Win!!!\033[0m')
    elif computer == '石头':
        print('\033[32;1mdraw\033[0m')
    else:
        print('\033[31;1mYou lose!!!\033[0m')
else:
    if computer == '剪刀':
        print('\033[31;1mYou lose!!!\033[0m')
    elif computer == '石头':
        print('\033[31;1mYou Win!!!\033[0m')
    else:
        print('\033[32;1mdraw\033[0m')
```



```python
import random
choices = ['剪刀', '石头', '布']
win_list = [['剪刀', '布'], ['石头', '剪刀'], ['布', '石头']] #将人胜利的情况前提定义至列表中,人在前,机器在后
computer = random.choice(choices)
player = input('请出拳(剪刀/石头/布): ')
print("Your choice: %s, Computer's choice: %s" % (player, computer))
if player == computer:
    print('\033[32;1mdraw\033[0m')
elif [player, computer] in win_list:
    print('\033[31;1mYou Win!!!\033[0m')
else:
    print('\033[31;1mYou lose!!!\033[0m')
```

```python
import random
choices = ['剪刀', '石头', '布']
win_list = [['剪刀', '布'], ['石头', '剪刀'], ['布', '石头']]
prompt = '''(0)剪刀
(1)石头
(2)布
请选择(0/1/2): '''
computer = random.choice(choices)
index = int(input(prompt))
player = choices[index]
print("Your choice: %s, Computer's choice: %s" % (player, computer))
if player == computer:
    print('\033[32;1mdraw\033[0m')
elif [player, computer] in win_list:
    print('\033[31;1mYou Win!!!\033[0m')
else:
    print('\033[31;1mYou lose!!!\033[0m')
```



## 二、while循环

### (一)循环语句基础

#### 1、循环概述

• 一组被重复执行的语句称之为循环体,能否继续重复,决定循环的终止条件
• Python中的循环有while循环和for循环
• 循环次数未知的情况下,建议采用while循环
• 循环次数可以预知的情况下,建议采用for循环

#### 2、while循环语法结构

• 当需要语句不断的重复执行时,可以使用while循环

```python
while expression:
while_suite
```

• 语句while_suite会被连续不断的循环执行,直到表达式的值变成0或False

```python
sum100	=	0                # 定义用于存储结果的变量
counter	=	1                # 定义计数器
while	counter	<=	100:     # 计数器不断的自增,每个计数器的值都累加到result中
    sum100	+=	counter
    counter	+=	1
print	("result	is	%d"	%	sum100)
```

```python
import random
choices = ['剪刀', '石头', '布']
win_list = [['剪刀', '布'], ['石头', '剪刀'], ['布', '石头']]
prompt = '''(0)剪刀
(1)石头
(2)布
请选择(0/1/2): '''
win = 0
lose = 0
while win < 2 and lose < 2 :   # 人机都没有赢够2次,才继续比赛
    computer = random.choice(choices)
    index = int(input(prompt))
    player = choices[index]
    print("Your choice: %s, Computer's choice: %s" % (player, computer))
    if player == computer:
        print('\033[32;1mdraw\033[0m')
    elif [player, computer] in win_list:
        print('\033[31;1mYou Win!!!\033[0m')
        win += 1
    else:
        print('\033[31;1mYou lose!!!\033[0m')
        lose += 1
```



### (二)循环语句进阶

#### 1、break语句

• break语句可以结束当前循环然后跳转到下条语句
• 写程序的时候,应尽量避免重复的代码,在这种情况下可以使用while-break结构

```python
name =	input('username:	')
while name !=	'tom':
name =	input('username:	')
#可以替换为
while True:
    name =	input('username:	')
    if name ==	'tom':
    break
```

```python
import random
choices = ['剪刀', '石头', '布']
win_list = [['剪刀', '布'], ['石头', '剪刀'], ['布', '石头']]
prompt = '''(0)剪刀
(1)石头
(2)布
请选择(0/1/2): '''
win = 0
lose = 0
while 1 :
    computer = random.choice(choices)
    index = int(input(prompt))
    player = choices[index]
    print("Your choice: %s, Computer's choice: %s" % (player, computer))
    if player == computer:
        print('\033[32;1mdraw\033[0m')
    elif [player, computer] in win_list:
        print('\033[31;1mYou Win!!!\033[0m')
        win += 1
    else:
        print('\033[31;1mYou lose!!!\033[0m')
        lose += 1
    if win == 2 or lose == 2 :
        break
```



#### 2、continue语句

• 当遇到continue语句时,程序会终止当前循环,并忽略剩余的语句,然后回到循环的顶端
• 如果仍然满足循环条件,循环体内语句继续执行,否则退出循环

```python
result = 0
counter = 0

while counter < 100 : 
    counter += 1
    if counter % 2 :  # counter % 2 的值只有0或1,0为False,1为True
        continue
    result += counter
print(result)
```



#### 3、else语句

• python中的while语句也支持else子句
• else子句只在循环完成后执行
• break语句也会跳过else块

```python
sum10	=	0
i =	1
while	i <=	10:
    sum10	+=	i
    i +=	1
else:
print	(sum10)	
```

```python
import random
num = random.randint(1, 100)     #生成一个1至100之间的整数,包括1和100
counter = 0
while counter < 7 :
    answer = int(input('请猜一个数字(1-100之间): '))
    if answer > num :
        print('猜大了')
    elif answer < num :
        print('猜小了')
    else:
        print('猜对了')
        break
    counter +=1
else:                           # 循环被break,else就不执行了,否则执行
    print('正确答案是: ', num)
```



## 三、for循环

### (一)for循环详解

#### 1、for循环语法结构

• python中的for接受可迭代对象(例如序列或迭代器)作为其参数,每次迭代其中一个元素

```python
for	iter_var in	iterable:
suite_to_repeat
```

• 与while循环一样,支持break、continue、else语句
• 一般情况下,循环次数未知采用while循环,循环次数已知,采用for循环

```python
s1 = 'abc'
for i in s1:
    print(i)
print('*' * 30)

num = [111, 222, 333]
for i in num:
    print(i)
print('*' * 30)

users = ('kate', 'cuihua', 'dachui')
for user in users:
    print(user)
print('*' * 30)

adict = {'name': 'tom', 'age': 25}
for key in adict:
    print(key, adict[key])
print('*' * 30)
```



#### 2、range函数

•生成数字

```python
# 只给定一个数字,是结束数字.结束数字不包含,起始数字从0开始
>>> range(10)
range(0, 10)
>>> list (range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list(range(6, 11))
[6, 7, 8, 9, 10]
>>> list(range(1, 11, 2))
[1, 3, 5, 7, 9]
>>> list(range(10, 0, -1))
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
>>> for i in range(1, 10):
...     print(i)
```

• for循环常与range函数一起使用
• range函数提供循环条件
• range函数的完整语法为:
range(start, end, step =1)

```python
result = 0
for i in range(1,10000001):
    result +=i
print(result)
```

案例6

1. 斐波那契数列就是某一个数,总是前两个数之和,比如0,1,1,2,3,5,8
2. 使用for循环和range函数编写一个程序,计算有10个数字的斐波那契数列
3. 改进程序,要求用户输入一个数字,可以生成用户需要长度的斐波那契数列

```python
fib = [0, 1]
for i in range(8):
    fib.append(fib[-1] + fib[-2])
print(fib)

fib = [0, 1]
n = int(input('长度: '))
for i in range(n - 2):
    fib.append(fib[-1] + fib[-2])
print(fib)
```



#### 3、列表解析:列表退守

• 用于生成列表

```python
>>> [10]
[10]
>>> [10 + 5] # 表达计算结果放到列表中
[15]
>>> [10 + 5 for i in range(10)] # 循环决定表达式计算的次数
[15, 15, 15, 15, 15, 15, 15, 15, 15, 15]
>>> [10 + i for i in range(1, 11)] # 表达式可以使用循环的变量
[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
>>> [10 + i for i in range(1, 11) if i % 2 == 1] # if作为过滤条件
[11, 13, 15, 17, 19]

['192.168.1.%d' %i for i in range(1, 255)]
```



• 它是一个非常有用、简单、而且灵活的工具,可以用来动态地创建列表
• 语法:
[expr for iter_var in	iterable]
• 这个语句的核心是for循环,它迭代iterable对象的所有条目
• expr应用于序列的每个成员,最后的结果值是该表达式产生的列表

案例7

1. 创建mtable.py程序
2. 乘序运行后,可以在屏幕上打印出九九乘法表
3. 修改程序,由用户输入数字,可打印任意数字的乘
法表

```python
for i in range(1, 10):
    for k in range(1, i+1):
        print('%d*%d=%d' % (i, k, i*k) , end = ' ')
    print()
    
i = 1
while i <= 9:
    j = 1
    while j <= i:
        print('%d*%d=%d' % (j, i, i*j) , end = ' ')
        j += 1
    print("")
    i += 1
```

# Python DAY03

## 一、文件对象

### （一）文件打开方法

#### 1、open内建函数

• 作为打开文件之门的“钥匙”,内建函数open() 提供了初始化输入/输出(I/O)操作的通用接口
• 成功打开文件后时候会返回一个文件对象,否则引发一个错误
• 基本语法:

```python
file_object = open(file_name, mode='r', buffering=-1)
```

#### 2、文件对象访问模式

| 文件模式 | 操作                                         |
| -------- | -------------------------------------------- |
| r        | 以读方式打开（文件不存在则报错）             |
| w        | 以写方式打开（文件存在则清空，不存在则创建） |
| a        | 以追加模式打开（必要时创建新文件）           |
| r+       | 以读写模式打开（参见r）                      |
| w+       | 以读写模式打开（参见w）                      |
| a+       | 以读写模式打开（参见a）                      |
| b        | 以二进制模式打开                             |

### （二）文件输入

#### 1、read方法

• read()方法用来直接读取字节到字符串中,最多读取给定数目个字节
• 如果没有给定size参数(默认值为-1)或者size值为负,文件将被读取直至末尾

#### 2、readline方法

• 读取打开文件的一行(读取下个行结束符之前的所有字节)
• 然后整行,包括行结束符,作为字符串返回
• 它也有一个可选的size参数,默认为-1,代表读至行结束符
• 如果提供了该参数,那么在超过size个字节后会返回不完整的行

#### 3、readlines方法

• readlines()方法读取所有(剩余的)行然后把它们作为一个字符串列表返回

#### 4、文件迭代

• 如果需要逐行处理文件,可以结合for循环迭代文件
• 迭代文件的方法与处理其他序列类型的数据类似

#### 5、读取文本文件

```python
(nsd1908) [student@room9pc01 day03]$ cp /etc/passwd /tmp/
>>> f = open('/tmp/passwd') # 默认以r方式打开
>>> data = f.read() #默认读取全部内容
>>> print(data)
>>> data = f.read() #继续向后读取
>>> data
‘’
>>> f.close()
>>> f = open('/tmp/passwd')
>>> f.read(4)    # 指定一次最多读取的字节数
'root'
>>> f.read(4)
':x:0'
>>> f.readline()  # 继续向后读取一行
':0:root:/root:/bin/bash\n'
>>> f.readlines() # 继续向后读取，将所有行读取到列表当中

# ***重要：以下方法是最常用的遍历文件的方法***
>>> f = open('/tmp/passwd')
>>> for i in f:
...     print(i, end='')
>>> f.close()
```

#### 6、读取非文本文件

```python
>>> f = open('/tmp/aaa.jpg', 'rb') #b表示bytes
>>> f.read(5) # 读取5字节
b'\xff\xd8\xff\xe0\x00' # 前面的b表示bytes
#2进制与15进制互转：4个2进制数换成一个16进制数
#0000->0;0001->1;0010->2;0011->3;0100->4
#1100->e;1111->f
>>> f.read(4096) # 建议一次读4k或4k的倍数
>>> f.close()
```

### 

### （三）文件输出

#### 1、write方法

• write()内建方法功能与read()和readline()相反。它把含有文本数据或二进制数据块的字符串写入到文件
中去
• 写入文件时,不会自动添加行结束标志,需要程序员手工输入

```python
>>> f = open('/tmp/a.txt', 'w')
>>> f.write('hello world\n')  
12
>>> f.flush()  # 立即将缓存数据同步至磁盘
(nsd1908) [student@room9pc01 day03]$ cat /tmp/a.txt
hello world
# 将字符串写到文件
>>> f.close()
```

#### 2、writelines方法

• 和readlines()一样,writelines()方法是针对列表的操作
• 它接受一个字符串列表作为参数,将它们写入文件
• 行结束符并不会被自动加入,所以如果需要的话,必须在调用writelines()前给每行结尾加上行结束符;

```python
>>> f.writelines(['2nd line.\n', '3rd line.\n'])
>>> f.close()
>>> 
(nsd1908) [student@room9pc01 day03]$ cat /tmp/a.txt
hello world
2nd line.
3rd line.
```

#### 3、以非文件形式写入文件

```python
>>> f = open('/tmp/a.txt', 'wb')
# 字符串前面加b，表示这个是bytes类型的数据。一个英文字符正好是一个字节。
>>> f.write(b'hello world!\n')
13
>>> f.write(b'你好\n') # 错误，因一个中文字符不是一个字节
  File "<stdin>", line 1
SyntaxError: bytes can only contain ASCII literal characters.
###########################################
>>> b1 = '你好！\n'
>>> type(b1)
<class 'str'>
>>> b1.encode()
b'\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x81\n'
##########################################
>>> f.write(b1.encode())
10
>>> f.close()
(nsd1908) [student@room9pc01 day03]$ cat /tmp/a.txt
hello world!
你好！
```

#### 4、字符编码

- 每个字符载计算机上存储的时候，都是使用2进制01进行表示
- 美国常用的ASCII码使用7位来表示一个字符；欧洲使用ISO-8859-1作为字符编码，它是在ASCII码基础上再扩展1位，使用8位来表示一个字符；中国常用的字符集是GB2312、GB18030、GBK
- ISO推出了unicode编码，被称作万国码。utf8编码是Unicode的一种编码方案，它采用变长的字节数表示一个字符。如1个英文字符占1个字节，一个汉子字符占3个字节。



### （四）操作文件

#### 1、with字句

• with语句是用来简化代码的
• 在将打开文件的操作放在with语句中,代码块结束后,文件将自动关闭

```python
>>> with open ('/tmp/passwd') as f:
...     f.readline()
... 
'root:x:0:0:root:/root:/bin/bash\n'
>>> f.readline()     # 报错，因为文件已经关闭了
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: I/O operation on closed file.
```



#### 2、文件内移动

•仅作了解即可

• seek(offset[, whence]):移动文件指针到不同的位置
– offset是相对于某个位置的偏移量
– whence的值,0表示文件开头,1表示当前位置,2表示文件的结尾
• tell():返回当前文件指针的位置

```python
>>> f = open('/tmp/passwd','rb')
>>> f.seek(16,0)                 #从开头偏移16个字符
16
>>> f.read(5)
b'/root'
>>> f.seek(-5,2)                 #从最后向左偏移5个字符
2332
>>> f.read()
b'bash\n'

```

#### 3、案例1

1. 创建cp.py文件

2. 将/bin/ls“拷贝”到/root/目录下

3. 不要修改原始文件

   ```python
   f = open('/bin/ls','rb')
   g = open('/root/ls','wb')
   
   data = f.read()
   g.write(data)
   
   f.close()
   g.close()
   ```

   以上拷贝文件的代码分析

   1、建议使用变量，而不是直接使用字面量。open的参数最好使用变量。

   2、变量名称应该有意义。f、g这样的名字不能体现出它代表什么。

   3、如果文件很大，一次性的将所有内容读取出来，将会消耗太多内存。应该每次读取少量数据，多读取几次。

   优化后代码如下：

   ```python
   src_fname = '/bin/ls'
   dst_fname = '/tmp/list2'
   src_fobj = open(src_fname, 'rb')
   dst_fobj = open(dst_fname, 'wb')
   
   while 1:
       data = src_fobj.read(4096)
       if not data: # 如内容已经全读完，则读到的是空串，空为假，取反则为真。
           break
       dst_fobj.write(data)
   
   src_fobj.close()
   dst_fobj.close()
   ```

   

## 二、函数基础

### （一）函数基本操作

#### 1、函数基本概念

• 函数是对程序逻辑进行结构化或过程化的一种编程方法
• 将整块代码巧妙地隔离成易于管理的小块
• 把重复代码放到函数中而不是进行大量的拷贝,这样既能节省空间,也有助于保持一致性
• 通常函数都是用于实现某一种功能

#### 2、创建函数

• 函数是用def语句来创建的,语法如下:

```
def function_name(arguments):
"function_documentation_string"
function_body_suite
```

• 标题行由def关键字,函数的名字,以及参数的集合(如果有的话)组成
• def子句的剩余部分包括了一个虽然可选但是强烈推荐的文档字串,和必需的函数体

#### 3、调用函数

• 同大多数语言相同,python用一对圆括号调用函数
• 如果没有加圆括号,只是对函数的引用

```python
def mk_fib():
    fib = [0, 1]
    n = int(input('长度: '))
    for i in range(n - 2):
        fib.append(fib[-1] + fib[-2])
    print(fib)

mk_fib()
```



#### 4、函数的返回值

• 多数情况下,函数并不直接输出数据,而是向调用者返回值
• 函数的返回值使用return关键字
• 没有return的话,函数默认返回None

```python
>>>	def foo():
...	  res =	3 + 4
>>>	i =	foo()
>>>	print(i)
None
```



### （二）函数参数

#### 1、定义参数

• 形式参数
– 函数定义时,紧跟在函数名后(圆括号内)的参数被称为形式参数,简称形参。由于它不是实际存在变量,所以又称虚拟变量
• 实际参数
– 在主调函数中调用一个函数时,函数名后面括弧中的参数(可以是一个表达式)称为“实际参数”,简称实参

#### 2、传递参数

• 调用函数时,实参的个数需要与形参个数一致
• 实参将依次传递给形参

```python
import  sys
print(sys.argv) # sys.argv是个列表,保存位置参数
```

```python
def mk_fib(n):
    fib = [0, 1]
    for i in range(n - 2):
        fib.append(fib[-1] + fib[-2])
    return  fib
for i  in [2, 8, 20]:
    print(mk_fib(i))
```



#### 3、位置参数

• 与shell脚本类似,程序名以及参数都以位置参数的方式传递给python程序
• 使用sys模块的argv列表接收

```python
import sys
def cp(src_fname, dst_fname):
    src_fobj = open(src_fname, 'rb')
    dst_fobj = open(dst_fname, 'wb')
    while 1:
        data = src_fobj.read(4096)
        if not data:
            break
        dst_fobj.write(data)
    src_fobj.close()
    dst_fobj.close()

cp(sys.argv[1], sys.argv[2]
```



#### 4、默认参数

• 默认参数就是声明了默认值的参数
• 因为给参数赋予了默认值,所以在函数调用时,不向该参数传入值也是允许的

```python
def pstar(n=30):
    print('*' * n )

pstar(1)
```



## 三、模块基础

### （一）定义模块

#### 1、模块基本概念

• 模块是从逻辑上组织python代码的形式
将程序文件的扩展名.py移除,剩下的文件名就是模块名
• 当代码量变得相当大的时候,最好把代码分成一些有组织的代码段,前提是保证它们的彼此交互
• 这些代码片段相互间有一定的联系,可能是一个包含数据成员和方法的类,也可能是一组相关但彼此独立的操作函数

#### 2、创建模块

• 模块物理层面上组织模块的方法是文件,每一个以.py作为结尾的python文件都是一个模块
• 模块名称切记不要与系统中已存在的模块重名
• 模块文件名字去掉后面的扩展名(.py)即为模块名

```python
# vim star.py
hi = 'longlong is an ironman'

def pstar(n=30):
    print('#' * n)

[root@room9pc01 day03]# python

>>> import star
>>> star.hi
'longlong is an ironman'
>>> star.pstar()
##############################

```



### （二）使用模块

#### 1、导入模块（import）

• 使用import导入模块
• 模块属性通过“模块名.属性”的方法调用
• 如果仅需要模块中的某些属性,也可以单独导入

```python
>>> import star  #常用
>>> from random import choice, randint #常用
>>> choice('abcd')
'a'
>>> randint(1, 100)
78
>>> import sys, getpass # 一行导入多个模块,不常用
>>> import getpass as gp # 导入模块的同时,为它起别名,不常用
>>> gp.getpass('password: ')

```



#### 2、模块加载（load）

导入模块时 ，模块文件的代码将会运行一遍，这叫加载。

• 一个模块只被加载一次,无论它被导入多少次
• 只加载一次可以阻止多重导入时代码被多次执行
• 如果两个文件相互导入,防止了无限的相互加载
• 模块加载时,顶层代码会自动执行,所以只将函数放入模块的顶层是良好的编程习惯



#### 3、模块导入的特性

• 模块具有一个_name_特殊属性
• 当模块文件直接执行时,__name__的值为'__main__'
• 当模块被另一个文件导入时,__name__的值就是该模块的名字

```python
(nsd1908) [student@room9pc01 day03]$ echo 'print(__name__)' > foo.py
(nsd1908) [student@room9pc01 day03]$ echo 'import foo' > bar.py
(nsd1908) [student@room9pc01 day03]$ cat foo.py 
print(__name__)
(nsd1908) [student@room9pc01 day03]$ cat bar.py 
import foo
(nsd1908) [student@room9pc01 day03]$ python foo.py 
__main__
(nsd1908) [student@room9pc01 day03]$ python bar.py 
foo

```



# Python DAY04

## 一、系统管理模块

### （一）shuti模块

python官方模块：https://docs.python.org/zh-cn/3/library/shutil.html

#### 1、复制和移动

• shutil.copyfileobj(fsrc, fdst[, length])
将类似文件的对象fsrc的内容复制到类似文件的对象fdst。
• shutil.copyfile(src, dst, *, follow_symlinks=True)将名为src的文件的内容(无元数据)复制到名为dst的文件,然后返回dst。

#### 2、目录操作

• shutil.copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False)
递归地复制以src为根的整个目录树,返回目标目录。由dst命名的目标目录不能已经存在。
• shutil.rmtree (path, ignore_errors=False, onerror=None)
删除整个目录树; 路径必须指向目录(而不是指向目录的符号链接)。

#### 3、权限管理

• shutil.copymode(src, dst, *, follow_symlinks=True)
将权限位从src复制到dst。文件内容,所有者和组不受影响。src和dst是以字符串形式给出的路径名称。
• shutil.copystat(src, dst, *, follow_symlinks=True)
将权限位,最后访问时间,上次修改时间和标志从src复制到dst。
• shutil.chown(path, user=None, group=None)
更改给定路径的所有者用户和/或组

```python
import shutil
f1 = open('/bin/touch','rb')
f2 = open('/tmp/tch', 'wb')
shutil.copyfileobj(f1, f2)
f1.close()
f2.close()

shutil.copy('/etc/hosts','/tmp/') # cp /etc/hosts /tmp/

shutil.copy2('/etc/hosts', '/tmp/zhuji') # cp -p /etc/hosts /tmp/zhuji

shutil.copytree('/etc/security', '/tmp/anquan') # cp -r 

shutil.move('/tmp/anquan', '/var/tmp') # mv

shutil.chown('/tmp/tch', 'tom', 'tom') #chown

help(shutil.chown) #查看shutil.chown的帮助

shutil.rmtree('/var/tmp/anquan') # rm -rf


```



### （二）subprocess模块

#### 1、概述

• subprocess模块主要用于执行系统命令
• subprocess模块允许你产生新的进程,连接到它们的输入/输出/错误管道,并获得它们的返回代码
• 本模块旨在替换几个较早的模块和功能,如os.system、os.spawn*

#### 2、run方法

• subprocess.run方法在python3.5引入。早期版本可以使用subprocess.call方法
• 直接执行命令

```python
import subprocess
subprocess.run('ls')
subprocess.run('ls /tmp', shell='true')

>>> result = subprocess.run('ls') # 将运行结果保存到变量中
anaconda-ks.cfg  bin  daima.rar  debian-binary  ls  original-ks.cfg  PycharmProjects  setip  y  y.pub  公共  模板  视频  图片  文档  下载  音乐  桌面
>>> result
CompletedProcess(args='ls', returncode=0)
>>> result.args
'ls'
>>> 
>>> result.returncode # 即$?
0

```

#### 3、输出和错误

run方法执行的结果默认打印在屏幕上,也可以通过管道将其存储在标准输出和标准错误中

```python
result = subprocess.run('id root; id zhangsan', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
#将标准输出保存到stdout，错误保存到stderr
print(result.stderr)
print(result.stdout)
print(result.stdout.decode()) # 将bytes类型转成str类型

```



## 二、语法风格及布局

### （一）语法风格

#### 1、变量赋值

• python支持链式多重赋值
x = y = 10
• 另一种将多个变量同时赋值的方法称为多元赋值,采用这种方式赋值时,等号两边的对象都是元组
a, b = 10, 20

```python
## 链式多重赋值

>>> alist = blist = [1, 2]
>>> alist
[1, 2]
>>> blist
[1, 2]
>>> blist[0] = 100
>>> blist
[100, 2]
>>> alist
[100, 2]
#链式多重赋值，对数字、字符串不会有像列表一样的影响
>>> a = b = 10
>>> b = 20
>>> a
10
>>> b
20

#多元赋值
>>> a, b = 10, 20
>>> c, d = (100, 200)
>>> e, f = 'xy'
>>> g, h = ['tom', 'jerry']

#交换两个变量的值
>>> a, b = 100, 200
>>> t = a
>>> a = b 
>>> b = t
>>> a
200
>>> b
100
#交换两个变量的值，python的方式：
>>> a, b = 100, 200
>>> a, b = b, a
>>> a
200
>>> b
100


```



#### 2、合法标识符

• python标识符字符串规则和其他大部分用C编写的高级语言相似
• 第一个字符必须是字母或下划线(_)
• 剩下的字符可以是字母和数字或下划线
• 大小写敏感

#### 3、关键字

• 和其他的高级语言一样,python也拥有一些被称作关键这字的保留字符
• 任何语言的关键字应该保持相对的稳定,但是因为python是一门不断成长和进化的语言,其关键字偶
尔会更新
• 关键字列表和iskeyword()函数都放入了keyword模块以便查阅

```python
>>> import keyword
>>> keyword.kwlist
['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
>>> keyword.iskeyword('pass')
True

```

#### 4、内建

官方说明：https://docs.python.org/zh-cn/3/library/functions.html

• 除了关键字之外,python还有可以在任何一级代码使用的“内建”的名字集合,这些名字可以由解释器
设置或使用
• 虽然built-in不是关键字,但是应该把它当作“系统保留字”



#### 5、模块结构及布局

• 编写程序时,应该建立一种统一且容易阅读的结构,并将它应用到每一个文件中去

```python
#！/usr/local/bin/python3   声明解释器
'''文档字符串（帮助信息中的name）

用于模块文件的帮助信息（帮助信息中的description）
'''
#模块的导入
import os
import time
from string import ascii_letters, digits

#全局变量定义
all_chs = ascii_letters + digits
debug = True

#类定义
class MyClass:
    pass

#函数定义
def pstar(n=30):
    '默认打印30个星号，也可以指定个数'（可以显示在帮助信息中）
    print('*' * n)

#主程序代码，程序主体
if __name__ == '__main__':
    print(hi)
    pstar(n=50)
```

#### 6、案例1

1. 编写一个程序,要求用户输入文件名

2. 如果文件已存在,要求用户重新输入

3. 提示用户输入数据,每行数据先写到列表中

4. 将列表数据写入到用户输入的文件名中

   编程思路：

   1、思考程序的运行方式。交互？非交互？

   ```python
   # python mkfile。py
   文件名：/etc
   文件已存在，请重试
   文件名：/etc/hosts
   文件已存在，请重试
   文件名：/etc/abc.txt
   请输入内容,在单独的一行输入end结束。
   （end to quit）:hello world！
   （end to quit）:2nd line.
   （end to quit）:the end.
    (end to quit):end
   # ls /tmp/abc.txt
   abc.txt
   # cat /tmp/abc.txt
   hello world！
   2nd line.
   the end.
   ```

   2、思考程序有哪些功能，将功能写为功能函数。

   ```python
   def get_fname():
       '用于获取并返回文件名'
   
   def get_content():
       '用于获取并返回文件内容'
   
   def wfile():
       '用于将内容写入文件'
   ```

   3、编写主程序，按逻辑调用相关函数

   ```python
   def get_fname():
       '用于获取并返回文件名'
   
   def get_content():
       '用于获取并返回文件内容'
   
   def wfile(fname, content):
       '用于将内容写入文件'
   
   if __name__ == '__main__':
       fname = get_fname()
       content = get_content()
       wfile(fname, content)
   ```

   4、完成每一个函数

   ```python
   import os
   def get_fname():
       '用于获取并返回文件名'
       while 1:
           fname = input('请输入文件名： ')
           if not os.path.exists(fname):
               break
           print('文件已存在，请重试!')
   
       return fname
   
   def get_content():
       '用于获取并返回文件内容'
       content = []
       print('请输入内容，在单独的一行输入end结束。')
       while 1:
           line = input('(end to quit): ')
           if line == 'end':
               break
           content.append(line)
       return content
   
   
   def wfile(fname, content):
       '用于将内容写入文件'
       with open(fname, 'w') as  fobj:
           fobj.writelines(content)
   
   if __name__ == '__main__':
       fname = get_fname()
       content = get_content()
       content = ['%s\n' % line for line in content]
       wfile(fname, content)
   ```

   

## 三、字符串详解

### （一）序列

#### 1、序列类型操作符

| 序列操作符     | 作用                             |
| -------------- | -------------------------------- |
| seq[ind]       | 获得下标为ind的元素              |
| seq[ind1:ind2] | 获得下标从ind1到ind2间的元素集合 |
| seq * expr     | 序列重复expr次                   |
| seq1 + seq2    | 连接序列seq1和seq2               |
| obj in seq     | 判断obj元素是否包含在seq中       |
| obj not in seq | 判断obj元素是否不包含在seq中     |



#### 2、内建函数

| 函 数       | 含 义                              |
| ----------- | ---------------------------------- |
| list(iter)  | 把可迭代对象转换为列表             |
| str(obj)    | 把obj对象转换成字符串              |
| tuple(iter) | 把一个可迭代对象转换成一个元组对象 |

• len(seq):返回seq的长度
• enumerate:接受一个可迭代对象作为参数,返回一个enumerate对象
• reversed(seq):接受一个序列作为参数,返回一个以逆序访问的迭代器
• sorted(iter):接受一个可迭代对象作为参数,返回一个有序的列表

```python
# enumerate（）可以同时得到下标和值
>>> user = ['tom', 'jerry', 'bob', 'alice']
>>> enumerate(user)
<enumerate object at 0x7ff36aa39a68>
>>> list(enumerate(user))
[(0, 'tom'), (1, 'jerry'), (2, 'bob'), (3, 'alice')]
>>> for data in enumerate(user):
...     print(data)
... 
(0, 'tom')
(1, 'jerry')
(2, 'bob')
(3, 'alice')
>>> for i, name in enumerate(user):
...     print(i, name)
... 
0 tom
1 jerry
2 bob
3 alice

```



### （二）字符串

#### 1、字符串操作符

属于标量、不可变

• 比较操作符:字符串大小按ASCII码值大小进行比较
• 切片操作符:[ ]、[ : ]、[ : : ]
• 成员关系操作符:in、not in

#### 2、格式化操作符

• 字符串可以使用格式化符号来表示特定含义

| 格式化字符 | 转换方式                      |
| ---------- | ----------------------------- |
| %c         | 转换成字符                    |
| %s         | 优先用str()函数进行字符串转换 |
| %d / %i    | 转成有符号十进制数            |
| %o         | 转成无符号八进制数            |
| %e / %E    | 转成科学计数法                |
| %f / %F    | 转成浮点数                    |

```python
# 基本格式
>>> '%s is %s years old' % ('tom', 20)
'tom is 20 years old'
# 如果字符串中只有一个占位符，后面的（）可以省略
>>> 'hi %s' % 'tom'
'hi tom'

# %d位整数
>>> '%s is %d years old' % ('tom', 20.5)
'tom is 20 years old'

>>> '%f' % (5 / 3)  # %f为浮点数
'1.666667'
>>> '%.2f' % (5 / 3) # 小数位取两位
'1.67'4
>>> '%6.2f' % (5 / 3) # 总宽度为6，小数位2位，不够宽度左侧补空格
'  1.67'

```

• 字符串可以使用格式化符号来表示特定含义

| 辅助指令 | 作用                                                 |
| -------- | ---------------------------------------------------- |
| *        | 定义宽度或者小数点精度                               |
| -        | 左对齐                                               |
| +        | 在正数前面显示加号                                   |
| <sp>     | 在正数前面显示空格                                   |
| #        | 在八进制数前面显示零0,在十六进制前面显示'0x'或者'0X' |
| 0        | 显示的数字前面填充0而不是默认的空格                  |

```python
>>> '%8s%8s' % ('name', 'age')
'    name     age'
>>> '%8s%8s' % ('tom', '35')
'     tom      35'
>>> '%-8s%-8s' % ('name', 'age')
'name    age     '
>>> '%-8s%-8s' % ('tom', '35')
'tom     35    

#以下不常用，了解
>>> '%e' % 120000   # 科学计数法
'1.200000e+05'
>>> '%#o' % 120000   # 转8进制表示
'0o352300'
>>> '%#x' % 120000   # 转16进制表示
'0x1d4c0'


```



#### 3、format函数

• 使用位置参数
– 'my name is {} ,age {}'.format('hoho',18)
• 使用关键字参数
– 'my name is {name},age is
{age}'.format({'name':'bob', 'age':23})
• 填充与格式化
– {:[填充字符][对齐方式 <^>][宽度]}
• 使用索引
– 'name is {0[0]} age is {0[1]}'.format(['bob', 23])

```python
# 字符串格式化，还可以使用字符串的format方法
print('{} is {} years old'.format('bob', 20))
print('{} is {} years old'.format( 20,  'bob'))
print('{1} is {0} years old'.format( 20,  'bob'))
#将[20,  'bob']作为一个整体，下标位0的是20，下标位1的是bob
print('{0[1]} is {0[0]} years old'.format( [20,  'bob']))
```

案例2

1. 编写一个程序,实现创建用户的功能

2. 提示用户输入用户名

3. 随机生成8位密码

4. 创建用户并设置密码

5. 将用户相关信息写入指定文件

   ```python
   import subprocess,sys
   from randpass2 import randpass
   
   def add_user(user, passwd, fname):
       result = subprocess.run('id %s &> /dev/null' % user, shell=True )
       if result.returncode == 0:
           print('用户已存在')
           #return类似于循环的break，函数遇到return就结束了
           return
   
       # 创建用户添加密码
       subprocess.run('useradd %s' % user, shell=True)
       subprocess.run('echo %s | passwd --stdin %s'% (passwd, user), shell=True)
   
       #将用户名和密码写入文件
       #info = "username:%s\npassword:%s\n" % (user, passwd)
       info = """username:%s
   password:%s
   """ % (user, passwd)
   
       #写入文件
       with open(fname, 'a') as fobj:
           fobj.write(info)
   if __name__ == '__main__':
       user = sys.argv[1]
       fname = sys.argv[2]
       passwd = randpass()
       add_user(user, passwd, fname)
   ```

   

#### 4、原始字符串操作符

• 原始字符串操作符是为了对付那些在字符串中出现的特殊字符
• 在原始字符串里,所有的字符都是直接按照字面的意思来使用,没有转义特殊或不能打印的字符

```python
>>>	winPath = "c:\windows\temp"
>>>	print(winPath)
c:\windows	emp
>>>	newPath = r"c:\windows\temp"
>>>	print(newPath)
c:\windows\temp
>>> wpath = "c:\\temp"
>>> print(wpath)
c:\temp

```

案例3:格式化输出

```python
from mktxtfile import get_contents
width = 48
contents = get_contents()
print('+%s+' % ('*' * 48))
for line in contents:
    print('+{:^48}+'.format(line))    
print('+%s+' % ('*' * 48))  
```



#### 5、内建函数

字符串官方方法：https://docs.python.org/zh-cn/3/library/stdtypes.html#text-sequence-type-str

• string.capitalize():把字符串的第一个字符大写
• string.center(width):返回一个原字符串居中,并使用空格填充至长度width 的新字符串
• string.count(str, beg=0,end=len(string)):返回str在string里面出现的次数,如果beg或者end指定则返回指定范围内str出现的次数

• string.endswith(obj, beg=0,end=len(string)):检查字符串是否以obj结束,如果beg或者end指定则检查指定的范围内是否以obj结束,如果是,返回True,否则返回False
• string.islower():如果string中包含至少一个区分大小写的字符,并且所有这些字符都是小写,则返回True,否则返回False

• string.strip():删除string 字符串两端的空白
• string.upper():转换string 中的小写字母为大写
• string.split(str="", num=string.count(str)):以str为分隔符切片string,如果num有指定值,则仅分隔num个子字符串

```python
>>> s1 = '\tHello World!    '
>>> s1.strip()   # 去除两端空白字符
'Hello World!'
>>> s1.lstrip()   # 去除左端空白字符
'Hello World!    '
>>> s1.rstrip()   # 去除右端空白字符
'\tHello World!'
>>> s2 = 'hao123'
>>> s2.center(30)
'            hao123            '
>>> s2.center(30, '*')
'************hao123************'
>>> s2.ljust(30)
'hao123                        '
>>> s2.rjust(30)
'                        hao123'
>>> s2.startswith('h')  # 字符串以h开头吗？
True
>>> s2.startswith('ha')  # 字符串以ha开头吗？
True
>>> s2.endswith('a')  # 字符串以a结尾吗？
False
>>> '1234'.isdigit()  # 判断字符串是不是都是数字
True
>>> s2.isdigit()
False
>>> s2.upper()   # 字母转大写
'HAO123'
>>> 'Hao123'.lower()   # 字母转小写
'hao123'
```



# Python DAY05

## 一、列表和元组

### （一）列表

#### 1、创建及访问列表

• 列表是有序、可变的数据类型
• 列表中可以包含不同类型的对象
• 列表可以由[]或工厂函数创建
• 支持下标及切片操作

#### 2、更新列表

• 通过下标只能更新值,不能使用标添加新值

```python
>>> alist = [1, 8, 54, 10, 3, 1]
>>> alist[2] = 80
>>> alist[2:4] = [1, 3, 5,10]
>>> alist
[1, 8, 1, 3, 5, 10, 3, 1]
>>> alit[3:3]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'alit' is not defined
>>> alist[3:3]
[]
>>> alist[3:3] = [10, 20]
>>> alist
[1, 8, 1, 10, 20, 3, 5, 10, 3, 1]
```



#### 3、列表内建函数

| 列表方法                | 操作                               |
| ----------------------- | ---------------------------------- |
| list.append(obj)        | 向列表中添加一个对象obj            |
| list.count(obj)         | 返回一个对象obj 在列表中出现的次数 |
| list.extend(seq)        | 把序列seq的内容添加到列表中        |
| list.index(obj)         | 返回obj对象的下标                  |
| list.insert(index, obj) | 在索引量为index 的位置插入对象obj  |
| list.reverse()          | 原地翻转列表                       |
| list.sort()             | 排序                               |



```python
>>> alist.append(10) #追加
>>> print(alist)
[1, 8, 1, 10, 20, 3, 5, 10, 3, 1, 10]
>>> alist.insert(1, 10) #在下标为1的位置插入数字10
>>> print(alist)
[1, 10, 8, 1, 10, 20, 3, 5, 10, 3, 1, 10]
>>> alist.count(10) #统计列表中10的个数
4
>>> alist.extend([100, 200, 300])  #向列表加入3项
>>> print(alist)
[1, 10, 8, 1, 10, 20, 3, 5, 10, 3, 1, 10, 100, 200, 300]
>>> alist.pop()   #默认删除最后一个数据
300 
>>> alist.pop(2)   #删除下标为2的数据
8
>>> alist.remove(10) #删除第一个位为10的数据，不返回值，没有return
>>> alist
[1, 1, 10, 20, 3, 5, 10, 3, 1, 10, 100, 200]
>>> alist.index(5)  #查询数据5的下标
5
>>> alist.sort()    # 升序排列
>>> alist
[1, 1, 1, 3, 3, 5, 10, 10, 10, 20, 100, 200]
>>> alist.reverse()  #翻转列表
>>> alist
[200, 100, 20, 10, 10, 10, 5, 3, 3, 1, 1, 1]

>>> clist = alist.copy()  #将alist的值赋值给clist，它们使用不同的地址空间
>>> clist
[200, 100, 20, 10, 10, 10, 5, 3, 3, 1, 1, 1]
>>> alist
[200, 100, 20, 10, 10, 10, 5, 3, 3, 1, 1, 1]
>>> clist.clear()     #清空clist
>>> clist
[]
>>> alist
[200, 100, 20, 10, 10, 10, 5, 3, 3, 1, 1, 1]

```



### （二）元组

#### 1、创建元组

• 通过()或工厂函数tuple()创建元组
• 元组是有序的、不可变类型、容器
• 与列表类似,作用于列表的操作,绝大数也可以作用于元组

元组相当于是不可变的列表

```python

```



#### 2、单元素元组

• 如果一个元组中只有一个元素,那么创建该元组的时候,需要加上一个逗号

```python
>>> a = (10)
>>> type(a)
<class 'int'>
>>> a = (10,)
>>> type(a)
<class 'tuple'>
>>> len(a)
1
```

#### 3、案例1：用列表构建栈结构

1. 栈是一个后进先出的结构

2. 编写一个程序,用列表实现栈结构

3. 需要支持压栈、出栈、查询功能

   思路：

   1、思考程序的运行方式

   ```python
   （0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：10
   无效的选择，请重新输入。
   （0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：2
   []
   （0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：0
   数据：
   输入位空
   （0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：0
   数据：hello
   （0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：0
   数据：world
   （0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：2
   ['hello', 'world']
   （0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：1
   从栈中，弹出了：hello
   （0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：1
   从栈中，弹出了：world
   （0）压栈stack = []
   def push_it():
       '用于实现压栈功能'
       data = input('数据： ').strip()
       if data: #非空字符串为真
           stack.append(data)
       else:
           print('\033[31;1m输入为空\033[0m')
   
   def pop_it():
       '用于实现出栈功能'
       if stack:  #非空列表为真
           print('从列中，弹出了：\033[34;1m%s\033[0m' % stack.pop())
       else:
           print('\033[31;1m列表为空\033[0m')
   
   def view_it():
       '用于实现查询功能'
       # print(stack)
       print(stack)
   def show_menu():
       '用于载屏幕上打印菜单，根据用户选择，调用相关功能函数'
       prompt =  '''（0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：'''
       while 1:
           choice = input(prompt).strip() #将输入的两端空白字符删除
           if choice not in ['0', '1', '2', '3']:
               print('无效的选择，请重新输入。')
               continue
   
           if choice == '0':
               push_it()
           elif choice == '1':
               pop_it()
           elif choice == '2':
               view_it()
           else:
               print('\nbyebye')
               break
   
   if __name__ == '__main__':
       show_menu()
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：1
   栈已经为空
   （0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：3
   byebye
   ```

   2、思考程序有哪些功能，将功能携程功能函数。

   3、编写主程序代码，按照一定的规则编写成程序。

   ```python
   def push_it():
       '用于实现压栈功能'
   
   def pop_it():
       '用于实现出栈功能'
   
   def view_it():
       '用于实现查询功能'
   
   def show_menu():
       '用于载屏幕上打印菜单，根据用户选择，调用相关功能函数'
   
   
   if __name__ == '__main__':
       show_menu()
   ```

   4、完成程序

   ```python
   stack = []
   def push_it():
       '用于实现压栈功能'
       data = input('数据： ').strip()
       if data: #非空字符串为真
           stack.append(data)
       else:
           print('\033[31;1m输入为空\033[0m')
   
   def pop_it():
       '用于实现出栈功能'
       if stack:  #非空列表为真
           print('从列中，弹出了：\033[34;1m%s\033[0m' % stack.pop())
       else:
           print('\033[31;1m列表为空\033[0m')
   
   def view_it():
       '用于实现查询功能'
       # print(stack)
       print(stack)
   def show_menu():
       '用于载屏幕上打印菜单，根据用户选择，调用相关功能函数'
       prompt =  '''（0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：'''
       while 1:
           choice = input(prompt).strip() #将输入的两端空白字符删除
           if choice not in ['0', '1', '2', '3']:
               print('无效的选择，请重新输入。')
               continue
   
           if choice == '0':
               push_it()
           elif choice == '1':
               pop_it()
           elif choice == '2':
               view_it()
           else:
               print('\nbyebye')
               break
   
   if __name__ == '__main__':
       show_menu()
   ```

   优化后：

   ```python
   stack = []
   def push_it():
       '用于实现压栈功能'
       data = input('数据： ').strip()
       if data: #非空字符串为真
           stack.append(data)
       else:
           print('\033[31;1m输入为空\033[0m')
   
   def pop_it():
       '用于实现出栈功能'
       if stack:  #非空列表为真
           print('从列中，弹出了：\033[34;1m%s\033[0m' % stack.pop())
       else:
           print('\033[31;1m列表为空\033[0m')
   
   def view_it():
       '用于实现查询功能'
       # print(stack)
       print(stack)
   def show_menu():
       '用于载屏幕上打印菜单，根据用户选择，调用相关功能函数'
       cmds = {'0': push_it, '1':pop_it, '2':view_it}
       prompt =  '''（0）压栈
   （1）出栈
   （2）查询
   （3）退出
   请选择（0/1/2/3）：'''
       while 1:
           choice = input(prompt).strip() #将输入的两端空白字符删除
           if choice not in ['0', '1', '2', '3']:
               print('无效的选择，请重新输入。')
               continue
   
           if choice == '3':
               print('\nbyebye')
               break
   
           cmds[choice]()
   
   if __name__ == '__main__':
       show_menu()
   ```

   

## 二、字典

### （一）字典基础操作

#### 1、创建字典

属于容器、可变、映射。

字典的key不能重复。

字典的key只能是不可变的对象。

• 通过{ }操作符创建字典
• 通过dict()工厂方法创建字典
• 通过fromkeys()创建具有相同值的默认字典

```python
>>> adict = dict(['ab',('name','tom'),['age', 20]])
>>> dict
<class 'dict'>
>>> adict
{'a': 'b', 'name': 'tom', 'age': 20}
>>> dict([('name', 'tom'), ('age', 20), ('email', 'tom@tedu.cn')])
{'name': 'tom', 'age': 20, 'email': 'tom@tedu.cn'}
>>> {}.fromkeys(['tom', 'bob', 'jerry'], 20)
{'tom': 20, 'bob': 20, 'jerry': 20}

>>> adict
{'a': 'b', 'name': 'tom', 'age': 20}
>>> 'tom' in adict   #tom是字典的key吗？

False
>>> 'name' in adict
True
>>> for key in adict:    #遍历字典
...     print(key, adict[key])
... 
a b
name tom
age 20
```



#### 2、访问字典

• 字典是映射类型,意味着它没有下标,访问字典中的
值需要使用相应的键

```python
>>>	for each_key in	adict:
...		print 'key=%s, value=%s' % (each_key,	adict[each_key])
key=age,	value=23
key=name,	value=bob
>>>	print('%(name)s'	%	adict)
bob
```



#### 3、更新字典

• 通过键更新字典
– 如果字典中有该键,则更新相关值
– 如果字典中没有该键,则向字典中添加新值

```python
>>>	print adict
{'age':	23,	'name':	'bob'}
>>>	adict['age']	=	22
>>>	print(adict)
{'age':	22,	'name':	'bob'}
>>>	adict['email']	=	'bob@tarena.com.cn'
>>>	print adict
{'age':	22,	'name':	'bob',	'email':	'bob@tarena.com.cn'}
```



#### 4、删除字典

#### 5、字典操作符

• 使用字典键查找操作符[ ],查找键所对应的值
• 使用in和not in判断键是否存在于字典中

```python
>>>	adict =	{'age':	23,	'name':	'bob'}
>>>	print(adict['name’])
Bob
>>>	'bob'	in	adict
False
>>>	'name'	in	adict
True
```



### （二）字典相关函数

#### 1、作用于字典的函数

• len():返回字典中元素的数目
• hash():本身不是为字典设计的,但是可以判断某个对象是否可以作为字典的键

```python
>>>	print(adict)
{'age':	23,	'name':	'bob’}
>>>	print(len(adict))
2
>>>	hash(3)
3
>>>	hash([])
Traceback (most recent call last):
File	"<stdin>",	line 1,	in	<module>
TypeError:	unhashable type:	'list’
```



#### 2、字典内建方法

• dict.copy():返回字典(深复制)的一个副本

• dict.get(key, default=None):对字典dict中的键key,返回它对应的值value,如果字典中不存在此键,
则返回default的值

• dict.setdefault(key, default=None):如果字典中
不存在key键,由dict[key]=default为它赋值

• dict.items():返回一个包含字典中(键,值)对元组的列表
• dict.keys():返回一个包含字典中键的列表
• dict.values():返回一个包含字典中所有值的列表
• dict.update(dict2):将字典dict2的键-值对添加到字典dict

```python
>>> adict.get('name')     #最常用的方法，通过可以去除value
'tom' 
>>> adict.get('phone')     #如果key不在字典中，默认返回none
>>> adict.get('phone', 'not found') # key不在字典中，返回值可以自行指定
'not found'
>>> adict.get('name', 'not found')
'tom'

# adict.clear()和adict.copy 是和列表的相关方法一样
print(adict.values()) #取出所有的value
print(adict.items)   #将字典每一项以（key， val）形式返回
list(addict.items)
adict.pop('a')   #通过key弹出value
print(adict)
```

#### 3、案例2:模拟用户登陆信息系统

1. 支持新用户注册,新用户名和密码注册到字典中

2. 支持老用户登陆,用户名和密码正确提示登陆成功

3. 主程序通过循环询问进行何种操作,根据用户的选择,执行注册或是登陆操作

  ```python
  import getpass
  
  info = {}
  
  def register():
      '用于注册用户'
      user = input('请输入用户名：').strip()
  
      if user and (user not in info):
          passwd = input('请输入密码：')
          info[user] = passwd
  
      else:
          print('用户已存在，请登录或修改密码！')
  
  def login():
      '用于验证登陆'
      user = input('请输入用户名：').strip()
      passwd = getpass.getpass('请输入密码：')
      #if user in info and passwd == info[user]:
      if info.get(user) == passwd:
          print('login successful')
      else:
          print('login incorrect!')
  
  def show_menu():
      cmds = {'0':register, '1':login}
      prompt = """
  (0)注册
  (1)登陆
  (2)退出
  请输入（0/1/2）：
      """
      while 1:
          choice = input(prompt).strip()
          if choice not in ['0', '1', '2']:
              print('无效输入，请重试')
              continue
  
          if choice == '2':
              print('\n886')
              break
  
          cmds[choice]()
  
  if __name__ == '__main__':
      show_menu()
  ```



#### 4、哈希算法

单向加密。只能通过原始数据生成密文，不能反推。

原始数据相同，得到的密文必定也是一样的。

```python
# 例如，tom和jerry的密码都是123456，但是存储的时候，密文不相同。
# 密文说明
# $算法$salt$通过密码和和salt算出来的密文
# 算法如果是md5为1，如果是sha512为6
# salt是随机字符串
```



三、集合

（一）集合基础

1、创建集合

集合元素必须是不可变对象

集合元素没有顺序

集合元素不能重复

集合就像是一个无值的字典

• 数学上,把set称做由不同的元素组成的集合,集合(set)的成员通常被称做集合元素
• 集合对象是一组无序排列的可哈希的值
• 集合有两种类型
– 可变集合set
– 不可变集合frozenset

```python
>>> aset = set('abc')
>>> bset = set('bcd')
>>> cset = set(['tom', 'bob', 'jerry'])
>>> aset
{'a', 'b', 'c'}
>>> bset
{'b', 'c', 'd'}
>>> cset
{'jerry', 'bob', 'tom'}
>>> for name in cset:
...     print(name)
... 
jerry
bob
tom
>>> len(cset)
3
>>> tom in cset
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'tom' is not defined
>>> 'tom' in cset
True
>>> set ('hello')
{'h', 'l', 'e', 'o'}

>>> aset & bset #交集
{'b', 'c'}
>>> aset | bset #并集
{'b', 'c', 'a', 'd'}
>>> aset - bset # 差补，aset中有，bset中无
{'a'}
>>> bset - aset
{'d'}

```



2、集合类型操作符

• 集合支持用in和not in操作符检查成员
• 能够通过len()检查集合大小

• 能够使用for迭代集合成员
• 不能取切片,没有键

（二）集合方法

1、集合的方法



